## 写在前面

原帖以及工具来自：

https://www.52pojie.cn/thread-1710146-1-1.html

https://github.com/DiamondHunters/NodeInject_Hook_example

最近在搞深度学习所以转移到linux系统上，希望使用Typora进行数据记录，然后在吾爱论坛内找到了上述老哥的文章，按照教程进行了操作，并对代码进行了稍加分析，希望可以对此感兴趣的朋友们可以借鉴参考。本人是Rust半入门小白，如果分析的不对还请指正。

详细的原理介绍请查看上贴，本教程主要记录一下在linux上操作的步骤，Mac也可以按照这个步骤进行激活。

我个人的理解如下： 在 Typora 加载 Crypto 和 electron-fetch 库时返回经过修改的对象，对 electron-fetch 对象根据请求链接返回 mock 的有效 License 结果。修改 Crypto 对象判断解密内容是否为 mock 内容来返回 mock 的解密 license 数据。最终实现了对验证流程的劫持，通过输入符合 typora 本地判断的激活码，hook 代码返回正确的验证数据。

## 激活操作的步骤

这是本人的Ubuntu系统信息：

```c
          	.-/+oossssoo+/-.               @linux 
        `:+ssssssssssssssssss+:`           ------------- 
      -+ssssssssssssssssssyyssss+-         OS: Ubuntu 22.04.3 LTS x86_64 
    .ossssssssssssssssssdMMMNysssso.       Host: 82K2 15ACH6 
   /ssssssssssshdmmNNmmyNMMMMhssssss/      Kernel: 6.2.0-39-generic 
  +ssssssssshmydMMMMMMMNddddyssssssss+     Uptime: 56 mins 
 /sssssssshNMMMyhhyyyyhmNMMMNhssssssss/    Packages: 1991 (dpkg), 15 (snap) 
.ssssssssdMMMNhsssssssssshNMMMdssssssss.   Shell: zsh 5.8.1 
+sssshhhyNMMNyssssssssssssyNMMMysssssss+   Resolution: 1920x1080 
ossyNMMMNyMMhsssssssssssssshmmmhssssssso   DE: GNOME 42.9 
ossyNMMMNyMMhsssssssssssssshmmmhssssssso   WM: Mutter 
+sssshhhyNMMNyssssssssssssyNMMMysssssss+   WM Theme: Yaru 
.ssssssssdMMMNhsssssssssshNMMMdssssssss.   Theme: Yaru-dark [GTK2/3] 
 /sssssssshNMMMyhhyyyyhdNMMMNhssssssss/    Icons: Yaru [GTK2/3] 
  +sssssssssdmydMMMMMMMMddddyssssssss+     Terminal: gnome-terminal 
   /ssssssssssshdmNNNNmyNMMMMhssssss/      CPU: AMD Ryzen 5 5600H with Radeon G 
    .ossssssssssssssssssdMMMNysssso.       GPU: AMD ATI 05:00.0 Cezanne 
      -+sssssssssssssssssyyyssss+-         GPU: NVIDIA GeForce RTX 3060 Mobile 
        `:+ssssssssssssssssss+:`           Memory: 3649MiB / 13817MiB 
            .-/+oossssoo+/-.
```

激活步骤大纲如下：

1. 下载Typora
2. 下载NodeInject_Hook_example
3. 配置 rust 编译环境
4. 构建自动注入工具并放在typora下运行
5. 运行脚本获取License
6. 填入激活码激活软件

### 下载Typora

```rust
# 下载 Typora
wget <https://download2.typoraio.cn/linux/typora_1.7.4_amd64.deb> --output-document typora.deb

# 安装命令
sudo dpkg -i typora.deb
```

### 下载NodeInject_Hook_example

```rust
git clone <https://github.com/DiamondHunters/NodeInject_Hook_example>
```

### 配置 rust 编译环境

运行[Rust官网](https://www.rust-lang.org/tools/install)的代码进行配置：

```rust
curl --proto '=https' --tlsv1.2 -sSf <https://sh.rustup.rs> | sh
```

### 构建自动注入工具并放在typora下运行

进入项目文件夹运行`cargo build`生成可执行文件

之后把生成的可执行文件移动到typora的安装目录下

```rust
sudo cp target/debug/license-gen /usr/share/typora
```

运行之后可以看到`license-gen`已经在Typora安装目录下了：

之后给可执行文件权限和运行它

### 运行脚本获取License

回到最初的项目目录运行`cargo build`和`cargo run`得到下面的输出：

### 填入激活码激活软件

## Rust代码的简单解读

这是用于生成许可证密钥（license key）的**`main.rs`**，使用了一个名为 **`random_string`** 的 crate 来生成随机字符串（**xxxxxx-xxxxxx-xxxxxx-xxxxxx的激活码**），还定义了一个常量 **`LICENSE_CHARS`**，其中包含了许可证密钥可能包含的字符集（"L23456789ABCDEFGHJKMNPQRSTUVWXYZ"）。我查了一下，这里面没有1和I是为了避免混淆。

```rust
// 导入 random_string crate 的 generate 函数
use random_string::generate;

// 定义许可证字符集合
const LICENSE_CHARS: &str = "L23456789ABCDEFGHJKMNPQRSTUVWXYZ";

fn main() {
    // 调用生成License函数
    generate_license();
}

fn generate_license(){
    // 生成一个长度为 22 的随机字符串
    let mut license = generate(22, LICENSE_CHARS);

    // 进行两次迭代，对字符串进行修改
    for n in 0..2 {
        let mut o = 0;
        
        // 在每次迭代中，每隔两个字符，寻找字符在字符集合中的位置，并进行数学运算
        for i in (0..16).step_by(2) {
            o += LICENSE_CHARS.find(&license[n + i..=n + i]).unwrap();
        }
        
        // 对运算的结果取模
        o %= LICENSE_CHARS.len();
        
        // 将运算的结果接到许可证字符串后面
        license += &LICENSE_CHARS[o..=o];
    }
    
    // 在特定位置插入连字符，模拟标准许可证密钥的格式, **xxxxxx-xxxxxx-xxxxxx-xxxxxx的形式**
    license.insert(6, '-');
    license.insert(13, '-');
    license.insert(20, '-');
    
    // 打印生成的许可证密钥
    println!("License for you: {}", license);
}
```

主函数是 **`generate_license()`**，它生成了一个长度为 22 的随机字符串，然后在特定位置插入了几个连字符，以模拟许可证密钥的标准格式。在生成初始的长度为 22 的许可证密钥后，脚本进入一个循环，两次迭代，每次迭代对已生成的密钥进行修改。在每次迭代中，它使用**`LICENSE_CHARS.find()`** 找到字符在 **`LICENSE_CHARS`** 字符集中的位置。

```rust
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "fastrand"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a407cfaa3385c4ae6b23e84623d48c2798d06e3e6a1878f7f59f17b3f86499"
dependencies = [
 "instant",
]

[[package]]
name = "instant"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c"
dependencies = [
 "cfg-if",
]

[[package]]
name = "license-gen"
version = "0.1.0"
dependencies = [
 "random-string",
]

[[package]]
name = "random-string"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf4e63111ec5292d8af9c220f06fe3bb87991cc78b6f1f7e291d1ae6b8a60817"
dependencies = [
 "fastrand",
]
```

`cargo.lock` 文件是 Rust 项目中的一个自动生成的文件，用于记录项目中使用的所有依赖项及其确切的版本信息。

1. **cfg-if (1.0.0)**: 一个用于配置宏的轻量级库，用于在编译时根据条件选择不同的实现。
2. **fastrand (1.8.0)**: 提供了一个快速的伪随机数生成器依赖了 `instant` 库。
3. **instant (0.1.12)**: 时间库，提供了 `Instant` 类型，用于获取当前时间的高精度计时。
4. **license-gen (0.1.0)**: 项目依赖了 `random-string` 库。
5. **random-string (1.0.0)**: 生成随机字符串的库依赖了 `fastrand` 库。
